# Mini CRM - Система распределения лидов между операторами

Мини-CRM система для автоматического распределения обращений лидов между операторами с учётом их загрузки и весовых коэффициентов по источникам.

## Технологический стек

- **Язык**: Python 3.12+
- **Web-фреймворк**: FastAPI
- **ORM**: SQLAlchemy (async)
- **База данных**: SQLite (файловая, через aiosqlite)

## Запуск проекта

### Вариант 1: Локальный запуск

#### Требования

- Python 3.12 или выше
- Poetry (для управления зависимостями)

#### Установка зависимостей

```bash
poetry install
```

#### Запуск сервера
```bash
alembic upgrade head #### для запуска миграций
```

```bash
poetry run uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

Или напрямую через Python:

```bash
poetry run python main.py
```

Сервер будет доступен по адресу: `http://localhost:8000`


### Вариант 2: Запуск через Docker

#### Требования

- Docker
- Docker Compose

#### Запуск

```bash
# Запуск в фоновом режиме
docker-compose up -d

# Просмотр логов
docker-compose logs -f

# Остановка
docker-compose down
```

Сервер будет доступен по адресу: `http://localhost:8000`


### Документация API

После запуска сервера доступна интерактивная документация:
- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`

## Модель данных

Система состоит из следующих основных сущностей:

### 1. **Lead (Лид)**
Представляет конечного клиента.

**Поля:**
- `id` - уникальный идентификатор
- `external_id` - внешний идентификатор лида (уникальный, используется для определения одного и того же лида)
- `created_at` - дата создания

**Связи:**
- Один лид может иметь множество обращений (`Interaction`)

**Как определяется один и тот же лид:**
Система использует поле `external_id` для однозначной идентификации лида. Если при создании обращения передаётся `external_id`, который уже существует в системе, обращение связывается с существующим лидом. Если такого `external_id` нет - создаётся новый лид.

### 2. **Operator (Оператор)**
Представляет оператора, который обрабатывает обращения.

**Поля:**
- `id` - уникальный идентификатор
- `name` - имя оператора
- `is_active` - флаг активности (может ли получать новые обращения)
- `limit` - лимит по максимальному количеству активных обращений

**Связи:**
- Один оператор может иметь множество обращений (`Interaction`)
- Один оператор может быть настроен для множества источников через `SourceOperator` (с разными весами)

### 3. **Source (Источник/Бот)**
Представляет канал, из которого пришло обращение (один из условных «30 ботов»).

**Поля:**
- `id` - уникальный идентификатор
- `name` - название источника (уникальное)

**Связи:**
- Один источник может иметь множество обращений (`Interaction`)
- Один источник может быть настроен для множества операторов через `SourceOperator` (с разными весами)

### 4. **SourceOperator (Конфигурация распределения)**
Связующая таблица между источниками и операторами, хранящая веса распределения.

**Поля:**
- `id` - уникальный идентификатор
- `source_id` - идентификатор источника
- `operator_id` - идентификатор оператора
- `weight` - числовой вес оператора для данного источника

**Особенности:**
- Уникальное ограничение на пару `(source_id, operator_id)`
- Вес определяет долю трафика, которую должен получать оператор
- Пример: для источника А оператор1 — вес 10, оператор2 — вес 30 → примерно 25% и 75% трафика соответственно
- Веса используются для вычисления приоритета при распределении: оператор с большим весом получает больше обращений, но при равной относительной нагрузке (score) приоритет у оператора с меньшим весом

### 5. **Interaction (Обращение/Контакт)**
Конкретный факт обращения лида из определённого источника.

**Поля:**
- `id` - уникальный идентификатор
- `created_at` - дата создания обращения
- `lead_id` - идентификатор лида
- `source_id` - идентификатор источника
- `operator_id` - идентификатор назначенного оператора (может быть `NULL`)
- `is_active` - флаг активности обращения (используется для подсчёта нагрузки)

**Связи:**
- Принадлежит одному лиду (`Lead`)
- Принадлежит одному источнику (`Source`)
- Может быть назначено одному оператору (`Operator`) или остаться без оператора

## Алгоритм распределения обращений

При создании нового обращения система выполняет следующие шаги:

### 1. Определение лида

- По `external_id` из входных данных система ищет существующего лида
- Если такой лид не найден - создаётся новый лид с переданным `external_id`
- Используется поле `external_id` для однозначной идентификации одного и того же лида

### 2. Определение доступных операторов для источника

Система находит всех операторов, которые:
- Назначены на данный источник в конфигурации (`SourceOperator`)
- Активны (`is_active = True`)
- Не превышают лимит нагрузки: количество активных обращений (`is_active = True`) < `limit`

**Нагрузка оператора** определяется как количество активных обращений (`Interaction` с `is_active = True`), назначенных данному оператору.

### 3. Распределение с учётом весов

Реализован алгоритм **Weighted Round-Robin** (детерминированный):

1. Для каждого доступного оператора вычисляется **score**:
   ```
   score = current_load / weight
   ```
   где:
   - `current_load` - текущее количество активных обращений оператора
   - `weight` - вес оператора для данного источника

2. Операторы сортируются по двум критериям:
   - **Основной критерий**: по возрастанию `score` (наименее загруженный относительно своего веса)
   - **Вторичный критерий**: при равных `score` выбирается оператор с **меньшим весом**

3. Выбирается оператор с минимальным `score` (при равных `score` - с меньшим весом)

4. Это обеспечивает распределение, при котором в среднем доля обращений соответствует весам:
   - Оператор с большим весом получает больше обращений
   - Оператор с меньшим весом получает меньше обращений
   - При равных весах нагрузка распределяется равномерно
   - **Важно**: При нулевой нагрузке у всех операторов выбирается оператор с меньшим весом, что обеспечивает правильное распределение с самого начала

**Как работает алгоритм:**

Score показывает, насколько оператор "отстаёт" от своей целевой доли трафика. Чем меньше score, тем меньше оператор отстаёт от своей доли, и тем больше ему нужно дать обращений, чтобы соблюсти пропорции весов.

**Примеры:**

*Пример 1: Разная относительная нагрузка*
- Оператор 1: вес = 10, нагрузка = 2 → score = 2/10 = 0.2 (20% от своего веса)
- Оператор 2: вес = 30, нагрузка = 5 → score = 5/30 = 0.167 (16.7% от своего веса)
- **Выбирается Оператор 2**, потому что его относительная нагрузка меньше (0.167 < 0.2)
- **Почему?** Оператор 2 должен получать в 3 раза больше обращений (вес 30 vs 10), но сейчас у него только в 2.5 раза больше (5 vs 2). Ему нужно больше обращений, чтобы достичь своей доли.

*Пример 2: Нулевая нагрузка (оба оператора свободны)*
- Оператор 1: вес = 100, нагрузка = 0 → score = 0.0
- Оператор 2: вес = 30, нагрузка = 0 → score = 0.0
- **Выбирается Оператор 2** (равные score, но меньший вес = 30)
- **Почему?** При равных score выбирается оператор с меньшим весом, чтобы начать распределение с правильной пропорции. Оператор с меньшим весом должен получать меньше обращений, поэтому ему даём первое обращение, чтобы потом оператор с большим весом получил больше.

*Пример 3: Пропорциональное распределение*
- Оператор 1: вес = 10, нагрузка = 1 → score = 0.1
- Оператор 2: вес = 30, нагрузка = 3 → score = 0.1
- **Выбирается Оператор 2** (равные score, но меньший вес = 30)
- **Почему?** Оба оператора имеют одинаковую относительную нагрузку (10%), но при равных score выбирается оператор с меньшим весом для поддержания правильной последовательности распределения.

### 4. Создание обращения

Система создаёт обращение (`Interaction`) и связывает его с:
- Лидом (найденным или созданным)
- Источником
- Назначенным оператором (если найден подходящий)

## Обработка отсутствия доступных операторов

Если подходящих операторов нет (все неактивны или превысили лимит), система:
- **Создаёт обращение без оператора** (`operator_id = NULL`)
- Возвращает успешный ответ с информацией об обращении
- Обращение сохраняется в системе и может быть обработано позже (например, при освобождении операторов или изменении их статуса)

Это позволяет не терять обращения и даёт возможность обработать их вручную или автоматически при появлении доступных операторов.

## API Endpoints

### Управление операторами

#### Создание оператора
```
POST /operators/
```

Тело запроса:
```json
{
  "name": "Оператор 1",
  "is_active": true,
  "limit": 10
}
```

#### Список операторов
```
GET /operators/
```

#### Обновление оператора
```
PATCH /operators/{operator_id}
```

Тело запроса (все поля опциональны):
```json
{
  "name": "Новое имя",
  "is_active": false,
  "limit": 20
}
```

### Управление источниками

#### Создание источника
```
POST /sources/
```

Тело запроса:
```json
{
  "name": "Telegram Bot"
}
```

#### Список источников
```
GET /sources/
```

#### Получение источника
```
GET /sources/{source_id}
```

### Настройка распределения по источникам

#### Добавление оператора к источнику
```
POST /sources/{source_id}/operators
```

Тело запроса:
```json
{
  "operator_id": 1,
  "weight": 30
}
```

#### Список операторов источника
```
GET /sources/{source_id}/operators
```

#### Обновление веса оператора
```
PATCH /sources/{source_id}/operators/{operator_id}
```

Тело запроса:
```json
{
  "weight": 50
}
```

#### Удаление оператора из источника
```
DELETE /sources/{source_id}/operators/{operator_id}
```

### Регистрация обращений

#### Создание обращения
```
POST /interactions
```

Тело запроса:
```json
{
  "external_lead_id": "lead_123",
  "source_id": 1
}
```

Возвращает информацию об обращении и назначенном операторе (если есть). Если оператор не назначен, поле `operator_id` будет `null`.

### Просмотр состояния

#### Список лидов с обращениями
```
GET /leads/
```

Возвращает список всех лидов с их обращениями. Позволяет увидеть, что один лид может иметь несколько обращений из разных источников.

#### Получение лида с обращениями
```
GET /leads/{lead_id}
```

Возвращает информацию о конкретном лиде со всеми его обращениями.

### Healthcheck

#### Проверка работоспособности
```
GET /health
```

Возвращает `{"msg": "healthy"}` при успешном ответе.

## Структура проекта

```
CRM/
├── api/                           # API endpoints
│   └── views/                     # Роутеры для различных сущностей
│       ├── __init__.py           # Объединение всех роутеров
│       ├── operators.py          # Управление операторами
│       ├── sources.py            # Управление источниками и конфигурацией
│       ├── interactions.py       # Регистрация обращений
│       └── leads.py              # Просмотр лидов и обращений
├── core/                          # Ядро приложения
│   ├── config.py                 # Конфигурация (настройки БД)
│   ├── database.py               # Настройка подключения к БД
│   ├── models/                   # SQLAlchemy модели
│   │   ├── base.py              # Базовый класс моделей
│   │   ├── lead.py              # Модель лида
│   │   ├── operator.py          # Модель оператора
│   │   ├── source.py            # Модель источника
│   │   ├── interaction.py       # Модель обращения
│   │   └── source_operator.py  # Модель конфигурации распределения
│   ├── repository/               # Репозитории для работы с БД
│   │   ├── base_repository.py   # Базовый репозиторий
│   │   ├── lead_repository.py
│   │   ├── operator_repository.py
│   │   ├── source_repository.py
│   │   ├── source_operator_repository.py
│   │   └── interaction_repository.py
│   ├── schemas/                  # Pydantic схемы для валидации
│   │   ├── lead.py
│   │   ├── operator.py
│   │   ├── source.py
│   │   ├── source_operator.py
│   │   └── interaction.py
│   └── services/                 # Бизнес-логика
│       ├── lead_service.py
│       ├── operator_service.py
│       ├── source_service.py
│       ├── interaction_service.py
│       └── assigment_service.py  # Логика распределения обращений
├── main.py                        # Точка входа приложения
├── pyproject.toml                # Зависимости проекта (Poetry)
├── poetry.lock                   # Зафиксированные версии зависимостей
├── Dockerfile                    # Docker образ приложения
└── docker-compose.yml            # Docker Compose конфигурация
```

## Особенности реализации

- Используется async/await для всех операций с БД (SQLAlchemy async)
- База данных SQLite хранится в файле `crm.db` (по умолчанию)
- Все модели наследуются от базового класса с полями `id` и `created_at`
- Архитектура: View → Service → Repository
- Используется Poetry для управления зависимостями

## Примеры использования

### 1. Настройка системы

```bash
# 1. Создать операторов
curl -X POST "http://localhost:8000/operators/" \
  -H "Content-Type: application/json" \
  -d '{"name": "Оператор 1", "is_active": true, "limit": 10}'

curl -X POST "http://localhost:8000/operators/" \
  -H "Content-Type: application/json" \
  -d '{"name": "Оператор 2", "is_active": true, "limit": 20}'

# 2. Создать источник
curl -X POST "http://localhost:8000/sources/" \
  -H "Content-Type: application/json" \
  -d '{"name": "Telegram Bot"}'

# 3. Настроить распределение (оператор 1 - вес 10, оператор 2 - вес 30)
curl -X POST "http://localhost:8000/sources/1/operators" \
  -H "Content-Type: application/json" \
  -d '{"operator_id": 1, "weight": 10}'

curl -X POST "http://localhost:8000/sources/1/operators" \
  -H "Content-Type: application/json" \
  -d '{"operator_id": 2, "weight": 30}'
```

### 2. Регистрация обращений

```bash
# Создать обращение от лида
curl -X POST "http://localhost:8000/interactions" \
  -H "Content-Type: application/json" \
  -d '{"external_lead_id": "user_123", "source_id": 1}'
```

### 3. Просмотр состояния

```bash
# Получить список всех лидов с обращениями
curl "http://localhost:8000/leads/"

# Получить конкретного лида
curl "http://localhost:8000/leads/1"
```
